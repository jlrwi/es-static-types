/*jslint
    fudge
*/

import {
    compose,
//    identity,
    flip,
    pipeN
} from "@jlrwi/combinators";
import {
    is_object,
    object_has_property
} from "@jlrwi/esfunctions";

// Static Land implementation of Array
const type_name = "esArray";

// Setoid :: a -> a -> boolean
const equals = function (content_type) {
    return function (xs) {
        return function (ys) {

            if (!Array.isArray (xs) || !Array.isArray (ys)) {
                return false;
            }

            if (xs.length !== ys.length) {
                return false;
            }

            // if xs longer than ys, will fail when ys[idx] = undefined
            return xs.every (function (val, idx) {
                return content_type.equals (val) (ys[idx]);
            });
        };
    };
};

// Ord :: a -> a -> Boolean
// true at first index where x[n] < y[n]
// or identical up to identical array lengths or y longer
const lte = function (content_type) {
    return function (ys) {
        return function (xs) {

            if (!Array.isArray (xs) || !Array.isArray (ys)) {
                return false;
            }

            // if .some() finishes, default result is that all xs lte ys
            let result = true;

            xs.some (function (val, idx) {

                // xs longer than ys - end loop, not lte
                // if xs is empty, will never reach this
                if (idx >= ys.length) {
                    result = false;
                    return true;
                }

                // keep iterating - still equal
                if (content_type.equals (ys[idx]) (val)) {
                    return false;
                }

                // done - found an index where lte
                if (content_type.lte (ys[idx]) (val)) {
                    result = true;
                    return true;
                }

                // By default, y[idx] > x[idx] - failed!
                result = false;
                return true;
            });

            return result;
        };
    };
};

// Apply :: [(a -> b)] -> [a] -> [b]
const ap = function (fs) {
    return function (xs) {
        let res = [];

        fs.forEach(function (f) {
            xs.forEach(function (x) {
                res.push(f(x));
            });
        });

        return Object.freeze(res);
    };
};

// Semigroup :: [a] -> [a] -> [a]
const concat = function (ys) {
    return function (xs) {
        return Object.freeze(ys.concat(xs));
    };
};

// Alt :: [a] -> [a] -> [a]
const alt = concat;

// Chain :: (a -> [b]) -> [a] -> [b]
const chain = function (f) {
    return function (xs) {
        let res = [];

        xs.forEach(function (x) {
            res = concat (res) (f (x));
        });

        return Object.freeze(res);
    };
};

// Extend :: ([a] -> b) -> [a] -> [b]
const extend = function (f) {
    return function (xs) {
        return Object.freeze(
            xs.map (function (ignore, idx) {
                return f (xs.slice (idx));
            })
        );
    };
};

// Comonad :: [a] -> a
/* const extract = function (xs) {

    if (xs.length === 0) {
        throw new TypeError("Cannot extract from empty list");
    }

    return xs[0];
}; */

// Monoid :: () -> []
const empty = function () {
    return Object.freeze([]);
};

// Filterable :: (a -> Boolean) -> [a] -> [a]
const filter = function (f) {
    return function (xs) {
        return Object.freeze(xs.filter(f));
    };
};

// Functor :: (a -> b) -> [a] -> [b]
const map = function (f) {
    return function (xs) {
        return Object.freeze(xs.map(f));
    };
};

// Applicative :: x -> [x]
const of = function (x) {
    return Object.freeze([x]);
};

// [a] -> a -> [a]
const append = function (xs) {
    return pipeN (
        of,
        concat (xs),
        Object.freeze
    );
//    return compose (Object.freeze) (compose (concat (xs)) (of));
};

// Traversable :: Applicative<U> -> (a -> U<b>) -> [a] -> U<[b]>
const traverse = function (of_T) {
    return function (f) {
        return reduce (function (acc) {
            return function (val) {
// Make an apply that's waiting for the acc to concat
//  Apply f to each value from array (which puts it into an applicative),
//  Then use the applicative's map to concat the value to the accumulator's
//      array of values
                return of_T.ap (
                    of_T.map (compose (flip (concat)) (of)) (f (val))
                ) (acc);
            };
        }) (of_T.of([]));
    };
};

// Foldable :: ((b, a) -> b) -> (_->b) -> [a] -> b
// Builtin Array.reduce is not curried
const reduce = function (f) {
    return function (initial) {
        return function (xs) {
            let acc = initial;
            xs.forEach (function (val) {
                acc = f (acc) (val);
            });
            return acc;
        };
    };
};

// Plus :: () -> []
const zero = empty;

// Sanctuary has chainRec

const validate = function (content_type) {
    return function (ary) {
        return (
            Array.isArray (ary)
            ? ary.every(content_type.validate)
            : false
        );
    };
};

// Takes an array and returns a frozen copy
// Needs self-reference to get name and validate()
const create = of;

// Have to pass a sl type module to get Setoid
const type_factory = function (type_of) {
    const base_type = {
        spec: "StaticLand",
        version: 1,
        type_name,
        alt,
        ap,
        chain,
        extend,
//        extract,
        concat,
        empty,
        filter,
        map,
        of,
        append,
        traverse,
        reduce,
        validate: Array.isArray,
        create,
        zero
    };

    if (is_object (type_of)) {

        const check_for_prop = flip (object_has_property) (type_of);

        if (check_for_prop ("equals")) {
            base_type.equals = equals (type_of);
        }

        if (check_for_prop ("lte")) {
            base_type.lte = lte (type_of);
        }

        if (check_for_prop ("validate")) {
            base_type.validate = validate (type_of);
        }

        base_type.type_name += "< " + type_of.type_name + " >";
    }

    return Object.freeze(base_type);
};









export default Object.freeze(type_factory);

