/*jslint
    unordered
*/

import {
    compose,
    compose2,
    constant,
    flip,
    pipeN
} from "@jlrwi/combinators";
import {
    array_map,
    array_append,
    array_concat,
    method,
    prop,
    is_object,
    functional_if,
    object_has_property,
    array_reduce
} from "@jlrwi/esfunctions";

// Static Land implementation of Array
const type_name = "esArray";

// Setoid :: a -> a -> boolean
const equals = function (content_type) {
    return function (xs) {
        return function (ys) {

            if (!Array.isArray(xs) || !Array.isArray(ys)) {
                return false;
            }

            if (xs.length !== ys.length) {
                return false;
            }

// if xs longer than ys, will fail when try ys[idx] === undefined
            return xs.every(function (val, idx) {
                return content_type.equals(val)(ys[idx]);
            });
        };
    };
};

// true at first index where x[n] < y[n] OR
// arrays identical up to identical lengths or y longer
// Ord :: a -> a -> Boolean
const lte = function (content_type) {
    return function (ys) {
        return function (xs) {

            if (!Array.isArray(xs) || !Array.isArray(ys)) {
                return false;
            }

// if .some() finishes, default result is that all xs lte ys
            let result = true;

            xs.some(function (val, idx) {

// xs longer than ys - end loop, not lte
// if xs is empty, will never reach this
                if (idx >= ys.length) {
                    result = false;
                    return true;
                }

// keep iterating - still equal
                if (content_type.equals(ys[idx])(val)) {
                    return false;
                }

// done - found an index where lte
                if (content_type.lte(ys[idx])(val)) {
                    result = true;
                    return true;
                }

// By default, y[idx] > x[idx] - failed!
                result = false;
                return true;
            });

            return result;
        };
    };
};

// Apply :: [(a -> b)] -> [a] -> [b]
const ap = function (fs) {
    return pipeN(
        flip(array_map),
        flip(method("flatMap"))(fs),
        Object.freeze
    );
};

// Semigroup :: [a] -> [a] -> [a]
const concat = array_concat;

// Alt :: [a] -> [a] -> [a]
const alt = concat;

// Chain :: (a -> [b]) -> [a] -> [b]
const chain = compose2(Object.freeze)(method("flatMap"));

// Extend :: ([a] -> b) -> [a] -> [b]
const extend = function (f) {
    return function (xs) {
        return Object.freeze(
            xs.map(function (ignore, idx) {
                return f(xs.slice(idx));
            })
        );
    };
};

// Comonad :: [a] -> a
/* const extract = function (xs) {

    if (xs.length === 0) {
        throw new TypeError("Cannot extract from empty list");
    }

    return xs[0];
}; */

// Monoid :: () -> []
const empty = function () {
    return Object.freeze([]);
};

// Filterable :: (a -> Boolean) -> [a] -> [a]
const filter = compose2(Object.freeze)(method("filter"));
//const filter = function (f) {
//    return function (xs) {
//        return Object.freeze(xs.filter(f));
//    };
//};

// Functor :: (a -> b) -> [a] -> [b]
const map = array_map;

// Applicative :: x -> [x]
const of = function (x) {
    return Object.freeze([x]);
};

// Traversable :: Applicative<U> -> (a -> U<b>) -> [a] -> U<[b]>
const traverse = function (of_T) {
    return function (f) {
        return reduce(function (acc) {
            return function (val) {
// Make an apply that's waiting for the acc to concat
//  Apply f to each value from array (which puts it into an applicative),
//  Then use the applicative's map to concat the value to the accumulator's
//      array of values
                return of_T.ap(
                    of_T.map(
                        compose(flip(concat))(of)
                    )(
                        f(val)
                    )
                )(
                    acc
                );
            };
        })(
            of_T.of([])
        );
    };
};

// Builtin Array.reduce is not curried
// Foldable :: ((b, a) -> b) -> (_->b) -> [a] -> b
const reduce = array_reduce;

// Plus :: () -> []
const zero = empty;

// Sanctuary has chainRec

const get = prop;

const set = function (idx) {
    return function (val) {
        return function (a) {
            return Object.freeze(
                [...a.slice(0, idx), val, ...a.slice(idx + 1)]
            );
        };
    };
};

const validate = function (content_type) {
    return functional_if(
        Array.isArray
    )(
        method("every")(content_type.validate)
    )(
        constant(false)
    );
//    return function (ary) {
//        return (
//            Array.isArray (ary)
//            ? ary.every(content_type.validate)
//            : false
//        );
//    };
};

// Takes an array and returns a frozen copy
// Needs self-reference to get name and validate()
const create = of;

// [a] -> a -> [a]
const append = array_append;

// Have to pass a sl type module to get Setoid
const type_factory = function (type_of) {
    const base_type = {
        spec: "curried-static-land",
        version: 1,
        type_name,
        alt,
        ap,
        chain,
        extend,
//        extract,
        concat,
        empty,
        filter,
        map,
        of,
        append,
        traverse,
        reduce,
        get,
        set,
        validate: Array.isArray,
        create,
        zero
    };

    if (is_object(type_of)) {

        const check_for_prop = flip(object_has_property)(type_of);

        if (check_for_prop("equals")) {
            base_type.equals = equals(type_of);
        }

        if (check_for_prop("lte")) {
            base_type.lte = lte(type_of);
        }

        if (check_for_prop("validate")) {
            base_type.validate = validate(type_of);
        }

        base_type.type_name += "< " + type_of.type_name + " >";
    }

    return Object.freeze(base_type);
};

//xtest         function (str) {return str.split("");},

export default Object.freeze(type_factory);
