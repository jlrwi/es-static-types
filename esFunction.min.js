/*jslint
    fudge
*/

import {
    apply,
    identity,
    compose,
    constant
} from "@jlrwi/combinators";
import {
    type_check
} from "@jlrwi/esfunctions";

// Static Land implementation of Function

const type_name = "esFunction";

// Semigroupoid :: f -> g -> a -> g a -> f g a
// Uses compose combinator

// back to front composition of array of fxs
const composeN = function (...fs) {
    const last_index = fs.length - 1;

    // If no functions passed in, just give back the input
    if (fs.length === 0) {
        return identity;
    }

    const composer = function (idx) {
        if (idx >= last_index) {
            return fs[idx];
        }

        return compose (fs[idx]) (composer (idx + 1));
    };

    return composer (0);
};

// Setoid :: a -> a -> Boolean
// Checks reference
// Sanctuary uses referential equality, but that is only a subset of equality
//   and thus not helpful

// Category id :: a -> a
const id = identity;

// Functor :: (b -> c) -> (a -> b) -> (a -> c)
const map = compose;

// Apply :: (a -> b -> c) -> (a -> b) -> (a -> c)
// Synonymous with ap combinator
const ap = function (fabc) {
    return function (fab) {
        return function (a) {
            return fabc (a) (fab (a));
        };
    };
};

// Chain :: (b -> a -> c) -> (a -> b) -> (a -> c)
// Synonymous with Warbler (Once Removed)? abc.abcc
const chain = function (fbac) {
    return function (fab) {
        return function (a) {
            return fbac (fab (a)) (a);
        };
    };
};

// Extend :: ((a -> b) -> c) -> (a -> b) -> (a -> c)
// fabc should take a->b and turn it into a c somehow
// inside fabc is a b->c
// Sanctuary uses concat on the input to the first fx
const extend = apply;
const extract = apply (identity);
/*
const extend = function (fabc) {
    return function (fab) {
        return function (a) {
            return fabc (fab) (a);
        };
    };
};
*/

// Profunctor :: (a -> b) -> (c -> d) -> (b -> c) -> (a -> c)
// Synonymous with Robin combinator? abc.bca
const promap = function (f) {
    return function (g) {
        return function (promap) {
            return composeN (g, promap, f);
        };
    };
};

// Applicative :: b -> (a -> b)
const of = constant;

// Contravariant :: (b -> a) -> (a -> c) -> (b  -> c)
// Synonymous with flip (compose)
const contramap = function (f) {
    return function (contravariant) {
        return compose (contravariant) (f);
    };
};

// Sanctuary has chainRec, equals, extend

const validate = type_check ("function");

const create = of;

// (a->b) -> a -> b
const run = apply;

const type_factory = function (ignore) {
    return Object.freeze({
        spec: "StaticLand",
        version: 1,
        type_name,
        ap,
        chain,
        compose,
        composeN,
        id,
        map,
        extend,
        extract,
        promap,
        of,
        contramap,
        create,
        validate,
        run
    });
};













export default Object.freeze(type_factory);
