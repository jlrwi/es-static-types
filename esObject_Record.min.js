/*jslint
    fudge
*/

/*
A record is essentially a single item of data with attributes. It cannot be a
functor because any function acting on it must be familiar with its structure.
Manipulation can be accomplished with lenses.
*/

import {
    flip,
    pipe
} from "@jlrwi/combinators";
import {
    object_has_property,
    object_create_pair,
    is_object,
    prop
} from "@jlrwi/esfunctions";

// Static Land implementation of Object as a record

const create = object_create_pair;

// Setoid :: a -> a -> boolean
const equals = function (spec) {
    return function (xs) {
        return function (ys) {

            // Verify xs has all of ys properties
            if (!Object.keys(ys).every(function (key) {
                return object_has_property(key)(xs);
            })) {
                return false;
            }

            // Will catch if ys doesn't have all of xs props
            return Object.keys(spec).every(function (key) {
                return spec[key].equals(xs[key])(ys[key]);
            });
        };
    };
};

// Semigroup :: {a} -> {a} -> {a}
// Concats each property using the record template
const concat = function (spec) {
    return function (x) {
        return function (y) {
            const mapper = function ([key, type_module]) {
//                const [key, type_module] = key_val;
                if (!object_has_property(key)(x)) {
                    return [key, y[key]];
                }
                if (!object_has_property(key)(y)) {
                    return [key, x[key]];
                }
                return [key, type_module.concat(x[key])(y[key])];
            };

            return Object.freeze(
                Object.fromEntries(
                    Object.entries(spec).map(mapper)
                )
            );
        };
    };
};

// Monoid :: () -> {}
// Uses the empty() from each prop in record spec
const empty = function (spec) {
    return function () {
        return Object.freeze(
            Object.fromEntries(
                Object.entries(spec).map(function ([key, type_module]) {
                    return [key, type_module.empty()];
                })
            )
        );
    };
};

/*
// Apply :: {(a -> b)} -> {a} -> {b}
// This could be a useful method, but it's not lawful
const ap = function (fs) {
    return function (xs) {
        let res = empty_object ();
        Object.keys(fs).forEach(function (key) {
            if (object_has_property (key) (xs)) {
                res[key] = fs[key] (xs[key]);
            }
        });
        return Object.freeze(res);
    };
};

// Run f on a specified property of a record
// This can also be accomplished with lenses
const map_prop = function (target_prop) {
    return function (f) {
        const result_calc = pipeN ([
            prop (target_prop),
            f,
            object_create_pair (target_prop)
        ]);

// a (c) (b (c))
        return ap (object_concat) (result_calc);
    };
};
*/

const get = prop;
const set = function (key) {
    return pipe(
        object_create_pair(key)
    )(
        flip(concat)
    );
};

const validate = function (spec) {
    return function (x) {
        return Object.keys(spec).every(function (key) {
            return spec[key].validate(x[key]);
        });
    };
};

// type_of is a template of the record
// each property value is a type module
const type_factory = function (type_of) {
    const base_type = {
        spec: "curried-static-land",
        version: 1,
        type_name: "esObject_Record",
        get,
        set,
        create
    };

    if (is_object(type_of)) {

        const check_for_prop = function (prop) {
            return Object.values(type_of).every(
                object_has_property(prop)
            );
        };

        if (check_for_prop("concat")) {
            base_type.concat = concat(type_of);
        }

        if (check_for_prop("empty")) {
            base_type.empty = empty(type_of);
        }

        if (check_for_prop("equals")) {
            base_type.equals = equals(type_of);
        }

        base_type.validate = validate(type_of);
    }

    return Object.freeze(base_type);
};

export default Object.freeze(type_factory);
