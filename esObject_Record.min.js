/*jslint
    unordered
*/

/*
A record is essentially a single item of data with attributes. It cannot be a
functor because any function acting on it must be familiar with its structure.
Manipulation can be accomplished with lenses.
*/

import {
    flip,
    pipe,
    pipeN
} from "@jlrwi/combinators";
import {
    object_has_property,
    object_create_pair,
    is_object,
    method,
    prop
} from "@jlrwi/esfunctions";

// Static Land implementation of Object as a record

const create = object_create_pair;

// Setoid :: a -> a -> boolean
const equals = function (spec) {
    return function (xs) {
        return function (ys) {

            // Verify xs has all of ys properties
            if (!Object.keys(ys).every(function (key) {
                return object_has_property(key)(xs);
            })) {
                return false;
            }

            // Will catch if ys doesn't have all of xs props
            return Object.keys(spec).every(function (key) {
                return spec[key].equals(xs[key])(ys[key]);
            });
        };
    };
};

// Semigroup :: {a} -> {a} -> {a}
// Concats each property using the record template
const concat = function (spec) {
    return function (x) {
        return function (y) {
            const mapper = function ([key, type_module]) {
//                const [key, type_module] = key_val;
                if (!object_has_property(key)(x)) {
                    return [key, y[key]];
                }
                if (!object_has_property(key)(y)) {
                    return [key, x[key]];
                }
                return [key, type_module.concat(x[key])(y[key])];
            };

            return Object.freeze(
                Object.fromEntries(
                    Object.entries(spec).map(mapper)
                )
            );
        };
    };
};

// Monoid :: () -> {}
// Uses the empty() from each prop in record spec
const empty = function (spec) {
    return function () {
        return Object.freeze(
            Object.fromEntries(
                Object.entries(spec).map(function ([key, type_module]) {
                    return [key, type_module.empty()];
                })
            )
        );
    };
};

// {(a -> b)} -> {a} -> {b}
// This approximates Apply algebra but is not lawful
// There is an implicit identity function in fs for all properties
const record_map = function (fs) {
    const entries_mapper = function ([key, val]) {
        return [
            key,
            (
                (object_has_property(key)(fs))
                ? fs[key](val)
                : val
            )
        ];
    };

    return pipeN(
        Object.entries,
        method("map")(entries_mapper),
        Object.fromEntries,
        Object.freeze
    );
};

/*
// Run f on a specified property of a record
// This can also be accomplished with lenses
const map_prop = function (target_prop) {
    return function (f) {
        const result_calc = pipeN ([
            prop (target_prop),
            f,
            object_create_pair (target_prop)
        ]);

// a (c) (b (c))
        return ap (object_concat) (result_calc);
    };
};
*/

const get = prop;
const set = function (key) {
    return pipe(
        object_create_pair(key)
    )(
        flip(concat)
    );
};

const validate = function (spec) {
    return function (x) {
        return Object.keys(spec).every(function (key) {
            return spec[key].validate(x[key]);
        });
    };
};

// type_of is a template of the record
// each property value is a type module
const type_factory = function (type_of) {
    const base_type = {
        spec: "curried-static-land",
        version: 1,
        type_name: "esObject_Record",
        get,
        set,
        create,
        record_map
    };

    if (is_object(type_of)) {
        const check_for_prop = function (prop) {
            return Object.values(type_of).every(object_has_property(prop));
        };

        if (check_for_prop("concat")) {
            base_type.concat = concat(type_of);
        }

        if (check_for_prop("empty")) {
            base_type.empty = empty(type_of);
        }

        if (check_for_prop("equals")) {
            base_type.equals = equals(type_of);
        }

        base_type.validate = validate(type_of);
    }

    return Object.freeze(base_type);
};

export default Object.freeze(type_factory);
