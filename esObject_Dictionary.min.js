/*jslint
    fudge
*/

import {
    compose,
    constant,
    flip,
    pipe
} from "@jlrwi/combinators";
import {
    prop,
    object_has_property,
    object_create_pair,
    object_append,
    empty_object,
    minimal_object,
    is_object
} from "@jlrwi/esfunctions";

// Static Land implementation of Object as a dictionary

const create = object_create_pair;

// Semigroup :: {a} -> {a} -> {a}
// With overwriting duplicate keys
const concat = function (objA) {
    return function (objB) {
        return Object.freeze(
            Object.assign (empty_object (), objA, objB)
        );
    };
};

// Monoid :: () -> {}
const empty = minimal_object;

const append = object_append;
//const append = function (obj) {
//    return function (key) {
//        return compose (concat (obj)) (object_create_pair (key));
//    };
//};

// Functor :: (a -> b) -> {a} -> {b}
const map = function (f) {
    return function (xs) {
        let obj = empty_object ();
        Object.keys(xs).forEach(function (key) {
            obj[key] = f (xs[key]);
        });
        return Object.freeze(obj);
    };
};

// Alt :: {a} -> {a} -> {a}
// With overwriting duplicate keys
const alt = concat;

// Plus :: () -> {}
const zero = empty;

// Functor :: {(a -> b)} -> {a} -> {b}
const ap = function (fs) {
    return function (xs) {
        let res = empty_object ();
        Object.keys(fs).forEach(function (key) {
            if (object_has_property (key) (xs)) {
                res[key] = fs[key] (xs[key]);
            }
        });
        return Object.freeze(res);
    };
};

const object_subset = function (keys) {
    return function (obj){
        let res = empty_object ();
        keys.forEach(function (key) {
            res[key] = obj[key];
        });
        return Object.freeze(res);
    };
};

// Extend :: ({a} -> b) -> {a} -> {b}
const extend = function (f) {
    return function (xs) {
        const key_lists = Object.keys(xs).sort().map(
            function (ignore, idx, keys) {
                return keys.slice (idx);
            }
        );
        let obj = empty_object ();
        key_lists.forEach(function (keys) {
            obj[keys[0]] = f (object_subset (keys) (xs));
        });
        return Object.freeze(obj);
    };
};

// Foldable :: ((c, (a, b)) -> c) -> c -> {a: b} -> c
const reduce = function (f) {
    return function (initial) {
        return function (xs) {
            let acc = initial;
            Object.keys(xs).forEach(function (key) {
                acc = f (acc) (object_create_pair (key) (xs[key]));
            });
            return acc;
        };
    };
};

// Traversable :: Applicative<U> -> (a -> U<b>) -> {a} -> U<{b}>
const traverse = function (of_T) {
    return function (f) {
        return reduce (function (acc) {
            return function (val) {
                const key = Object.keys(val)[0];

                // Make an apply that's waiting for the acc to concat
                return of_T.ap (
                    of_T.map (
                        // Make the result of f back into an object, then concat
                        pipe (
                            create (key)
                        ) (
                            flip (concat)
                        )
                    ) (
                        f (val[key])
                    )
                ) (acc);
            };
        }) (of_T.of(empty_object ()));
    };
};

// Filterable :: (a -> Boolean) -> {a} -> {a}
const filter = function (f) {
    return function (xs) {
        let res = empty_object ();
        Object.keys(xs).forEach(function (key) {
            if (f (xs[key]) === true) {
                res[key] = xs[key];
            }
        });
        return Object.freeze(res);
    };
};

// Setoid :: a -> a -> boolean
const object_equals = function (content_type) {
    return function (xs) {
        return function (ys) {

            // Verify xs has all of ys properties
            if (!Object.keys(ys).every(function (key) {
                return object_has_property (key) (xs);
            })) {
                return false;
            }

            // Will catch if ys doesn't have all of xs props
            return Object.keys(xs).every(function (key) {
                return content_type.equals (xs[key]) (ys[key]);
            });
        };
    };
};

// Ord :: a -> a -> Boolean
// true at either (for sorted list of keys):
// -first index where xs[key] < ys[key]
// -first index where xs is missing one of ys keys
// -both objects identical for all keys
const lte = function (content_type) {
    return function (ys) {
        return function (xs) {
            // if .some() finishes, default result is that all xs lte ys
            let result = true;

            // Create an object with all the keys from both objects
            const key_list = concat (
                map (constant (true)) (xs)
            ) (
                map (constant (true)) (ys)
            );

            Object.keys(key_list).sort().some(function (key) {

                // ys has a prop not in xs - end loop, is lte
                if (!object_has_property (key) (xs)) {
                    return true;
                }

                // xs has a prop not in ys - end loop, not lte
                // if xs is empty, will never reach this
                if (!object_has_property (key) (ys)) {
                    result = false;
                    return true;
                }

                // keep iterating - still equal
                if (content_type.equals (ys[key]) (xs[key])) {
                    return false;
                }

                // done - found a prop where lte
                if (content_type.lte (ys[key]) (xs[key])) {
                    return true;
                }

                // By default, ys[key] > xs[key] - failed!
                result = false;
                return true;
            });

            return result;
        };
    };
};

// ((a, b) -> c), {a: b} -> {a: c}
// Could implement using reduce
/*const map_binary = function (f) {
    return function (obj) {
        let res = empty_object ();

        Object.keys(obj).forEach(function (key) {
            res[key] = f (key) (obj[key]);
        });

        return res;
    };
}; */

//unused?
const bimap = function (f) {
    return function (g) {
        return function (obj) {
            let res = empty_object ();

            Object.keys(obj).forEach(function (key) {
                res[f (key)] = g (obj[key]);
            });

            return res;
        };
    };
};

// Comonad :: {a} -> a
// would need to return a pair?
//const extract = function (xs) {
//    return xs[Object.keys(xs).sort()[0]];
//};

const get = prop;
const set = function (key) {
    return compose (flip (concat)) (object_create_pair (key));
//    return function (val) {
//        return function (o) {
// JSLint doesn't like
//            return Object.freeze({...o, [key]: val});
//        };
//    };
};

const validate = function (content_type) {
    return function (obj) {
        return (
            is_object (obj)
            ? Object.values(obj).every(content_type.validate)
            : false
        );
    };
};

const type_factory = function (type_of) {
    let base_type = {
        spec: "StaticLand",
        version: 1,
        type_name: "esObject_Dictionary",
        map,
        alt,
        zero,
        ap,
        extend,
        reduce,
        traverse,
        filter,
        concat,
        empty,
        append,
        get,
        set,
        create,
        validate: is_object
    };

    if (is_object (type_of)) {

        const check_for_prop = flip (object_has_property) (type_of);

        if (check_for_prop ("equals")) {
            base_type.equals = object_equals (type_of);
        }

        if (check_for_prop ("lte")) {
            base_type.lte = lte (type_of);
        }

        if (check_for_prop ("validate")) {
            base_type.validate = validate (type_of);
        }

        base_type.type_name += "< " + type_of.type_name + " >";
    }

    return Object.freeze(base_type);
};

export default Object.freeze(type_factory);
