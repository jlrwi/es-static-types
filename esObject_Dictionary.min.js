/*jslint
    unordered
*/

import {
    compose,
    constant,
    flip,
    pipe,
    pipeN
} from "@jlrwi/combinators";
import {
    prop,
    object_has_property,
    method,
    object_create_pair,
    object_append,
    empty_object,
    minimal_object,
    array_map,
    is_object
} from "@jlrwi/esfunctions";

// Static Land implementation of Object as a dictionary

const create = object_create_pair;

// Semigroup :: {a} -> {a} -> {a}
// With overwriting duplicate keys
const concat = function (objA) {
    return function (objB) {
        return Object.freeze(
            Object.assign(empty_object(), objA, objB)
        );
    };
};

const append = object_append;

// Monoid :: () -> {}
const empty = minimal_object;

// Functor :: (a -> b) -> {a} -> {b}
const map = function (f) {
    const mapper = function ([key, value]) {
        return [
            key,
            f(value)
        ];
    };

    return pipeN(
        Object.entries,
        method("map")(mapper),
        Object.fromEntries,
        Object.freeze
    );
};

// Alt :: {a} -> {a} -> {a}
// With overwriting duplicate keys
const alt = concat;

// Plus :: () -> {}
const zero = empty;

// Apply :: {(a -> b)} -> {a} -> {b}
const ap = function (fs) {
    return function (xs) {
//        let res = empty_object();
//        Object.keys(fs).forEach(function (key) {
//            if (object_has_property(key)(xs)) {
//                res[key] = fs[key](xs[key]);
//            }
//        });
//        return Object.freeze(res);
        const reducer = function (res, key) {
            if (object_has_property(key)(xs)) {
                res[key] = fs[key](xs[key]);
            }
            return res;
        };

        return Object.freeze(
            Object.keys(fs).reduce(reducer, {})
        );
    };
};

const object_subset = function (keys) {
    return function (obj) {
//        let res = empty_object();
//        keys.forEach(function (key) {
//            res[key] = obj[key];
//        });
//        return Object.freeze(res);
        const reducer = function (res, key) {
            res[key] = obj[key];
            return res;
        };

        return Object.freeze(keys.reduce(reducer, {}));
    };
};

// Extend :: ({a} -> b) -> {a} -> {b}
const extend = function (f) {
    return function (obj) {
        const key_lists = Object.keys(obj).sort().map(
            function (ignore, idx, keys) {
                return keys.slice(idx);
            }
        );
//        let obj = empty_object();
//        key_lists.forEach(function (keys) {
//            obj[keys[0]] = f(object_subset(keys)(xs));
//        });
//        return Object.freeze(obj);

        const reducer = function (res, keys) {
            res[keys[0]] = f(object_subset(keys)(obj));
            return res;
        };

        return Object.freeze(key_lists.reduce(reducer, {}));
    };
};

// Foldable :: ((c, {a: b}) -> c) -> c -> {a: b} -> c
const reduce = function (f) {
    return function (initial = {}) {
        return function (obj) {
//            let acc = initial;
//            Object.entries(xs).forEach(function ([key, val]) {
//                acc = f(
//                    acc
//                )(
//                    object_create_pair(key)(val)
//                );
//            });
//            return Object.freeze(acc);
            const reducer = function (res, key_val) {
                return f(res)(Object.fromEntries([key_val]));
            };

            return Object.freeze(
                Object.entries(obj).reduce(reducer, initial)
            );
        };
    };
};

// Traversable :: Applicative<U> -> (a -> U<b>) -> {a} -> U<{b}>
const traverse = function (of_T) {
    return function (f) {
        return reduce(function (acc) {
            return function (val) {
                const key = Object.keys(val)[0];

                // Make an apply that's waiting for the acc to concat
                return of_T.ap(
                    of_T.map(
                        // Make the result of f back into an object, then concat
                        pipe(
                            create(key)
                        )(
                            flip(concat)
                        )
                    )(
                        f(val[key])
                    )
                )(
                    acc
                );
            };
        })(
            of_T.of(empty_object())
        );
    };
};

// Filterable :: (a -> Boolean) -> {a} -> {a}
const filter = function (f) {
    return pipeN(
        Object.entries,
        method("filter")(compose(f)(prop(1))),
        Object.fromEntries,
        Object.freeze
    );
};

// Setoid :: a -> a -> boolean
const object_equals = function (content_type) {
    return function (xs) {
        return function (ys) {

            // Verify xs has all of ys properties
            if (!Object.keys(ys).every(function (key) {
                return object_has_property(key)(xs);
            })) {
                return false;
            }

            // Will catch if ys doesn't have all of xs props
            return Object.keys(xs).every(function (key) {
                return content_type.equals(xs[key])(ys[key]);
            });
        };
    };
};

// Ord :: a -> a -> Boolean
// true at either (for sorted list of keys):
// -first index where xs[key] < ys[key]
// -first index where xs is missing one of ys keys
// -both objects identical for all keys
const lte = function (content_type) {
    return function (ys) {
        return function (xs) {
            // if .some() finishes, default result is that all xs lte ys
            let result = true;

            // Create an object with all the keys from both objects
            const key_list = concat(
                map(constant(true))(xs)
            )(
                map(constant(true))(ys)
            );

            Object.keys(key_list).sort().some(function (key) {

                // ys has a prop not in xs - end loop, is lte
                if (!object_has_property(key)(xs)) {
                    return true;
                }

                // xs has a prop not in ys - end loop, not lte
                // if xs is empty, will never reach this
                if (!object_has_property(key)(ys)) {
                    result = false;
                    return true;
                }

                // keep iterating - still equal
                if (content_type.equals(ys[key])(xs[key])) {
                    return false;
                }

                // done - found a prop where lte
                if (content_type.lte(ys[key])(xs[key])) {
                    return true;
                }

                // By default, ys[key] > xs[key] - failed!
                result = false;
                return true;
            });

            return result;
        };
    };
};

// ((a, b) -> c), {a: b} -> {a: c}
// Could implement using reduce
/*const map_binary = function (f) {
    return function (obj) {
        let res = empty_object();

        Object.keys(obj).forEach(function (key) {
            res[key] = f(key)(obj[key]);
        });

        return res;
    };
}; */

//unused?

// Bifunctor :: f -> g -> a -> a
// (a -> b) -> (c -> d) -> {a: c} -> {b: d}
const bimap = function (f) {
    return function (g) {
        const mapper = function ([key, val]) {
            return [f(key), g(val)];
        };

        return pipeN(
            Object.entries,
            array_map(mapper),
            Object.fromEntries,
            Object.freeze
        );
    };
};

// Comonad :: {a} -> a
// would need to return a pair?
//const extract = function (xs) {
//    return xs[Object.keys(xs).sort()[0]];
//};

const get = prop;
const set = function (key) {
    return pipe(
        object_create_pair(key)
    )(
        flip(concat)
    );
};

const validate = function (content_type) {
    return function (obj) {
        return (
            is_object(obj)
            ? Object.values(obj).every(content_type.validate)
            : false
        );
    };
};

const type_factory = function (type_of) {
    let base_type = {
        spec: "curried-static-land",
        version: 1,
        type_name: "esObject_Dictionary",
        map,
        alt,
        zero,
        ap,
        extend,
        reduce,
        traverse,
        bimap,
        filter,
        concat,
        empty,
        append,
        get,
        set,
        create,
        validate: is_object
    };

    if (is_object(type_of)) {

        const check_for_prop = flip(object_has_property)(type_of);

        if (check_for_prop("equals")) {
            base_type.equals = object_equals(type_of);
        }

        if (check_for_prop("lte")) {
            base_type.lte = lte(type_of);
        }

        if (check_for_prop("validate")) {
            base_type.validate = validate(type_of);
        }

        base_type.type_name += "< " + type_of.type_name + " >";
    }

    return Object.freeze(base_type);
};

export default Object.freeze(type_factory);
