/*jslint
    fudge
*/

import {
    compose,
    flip,
    pipe
} from "@jlrwi/combinators";
import {
    object_has_property,
    is_object
} from "@jlrwi/esfunctions";

const map_set = function (obj) {
    return function (key) {
        return function (val) {
            return obj.set(key, val);
        };
    };
};

const map_get = function (obj) {
    return function (key) {
        return obj.get(key);
    };
};

const create = function (key) {
    return function (val) {
        return Object.freeze(new Map([[key, val]]));
    };
};

const new_map = function (contents) {
    return Object.freeze(new Map(contents));
};

// Semigroup :: <a> -> <a> -> <a>
// With overwriting duplicate keys
const concat = function (objA) {
    return function (objB) {
        let result = new_map (objA);
        objB.forEach(function (val, key) {
            result.set(key, val);
        });
        return Object.freeze(result);
    };
};

// Monoid :: () -> {}
const empty = new_map;

const append = compose (map_set) (new_map);

// Functor :: (a -> b) -> <a> -> <b>
const map = function (f) {
    return function (xs) {
        let obj = new Map();
        xs.forEach(function (val, key) {
            obj.set(key, f(val));
        });
        return Object.freeze(obj);
    };
};

// Alt :: <a> -> <a> -> <a>
// With overwriting duplicate keys
const alt = concat;

// Plus :: () -> {}
const zero = empty;

// Functor :: <(a -> b)> -> <a> -> <b>
const ap = function (fs) {
    return function (xs) {
        let res = new Map();
        fs.forEach(function (f, key) {
            const val = xs.get(key);
            if (val !== undefined) {
                res.set(key, f(val));
            }
        });
        return Object.freeze(res);
    };
};

// Traversable :: Applicative<U> -> (a -> U<b>) -> <a> -> U<<b>>
const traverse = function (of_T) {
    return function (f) {
        return reduce (function (acc) {
            return function (val) {
                const first = val.entries().next().value;
                const key = first[0];
                const value = first[1];

                // Make an apply that's waiting for the acc to concat
                return of_T.ap (
                    of_T.map (
                        // Make the result of f back into an object, then concat
                        pipe (
                            create (key)
                        ) (
                            flip (concat)
                        )
                    ) (
                        f (value)
                    )
                ) (acc);
            };
        }) (of_T.of(new Map ()));
    };
};

// Foldable :: ((c, (a, b)) -> c) -> c -> <a: b> -> c
const reduce = function (f) {
    return function (initial) {
        return function (xs) {
            let acc = initial;
            xs.forEach(function (val, key) {
                acc = f (acc) (create (key) (val));
            });
            return acc;
        };
    };
};

// Filterable :: (a -> Boolean) -> <a> -> <a>
const filter = function (f) {
    return function (xs) {
        let res = new Map();
        xs.forEach(function (val, key) {
            if (f (val) === true) {
                res.set(key, val);
            }
        });
        return Object.freeze(res);
    };
};

// Setoid :: a -> a -> boolean
const map_equals = function (content_type) {
    return function (xs) {
        return function (ys) {

            // Verify xs has all of ys properties
            if (!Array.from(ys.keys()).every(function (key) {
                return xs.has(key);
            })) {
                return false;
            }

            // Will catch if ys doesn't have all of xs props
            return Array.from(xs.keys()).every(function (key) {
                return content_type.equals (xs.get(key)) (ys.get(key));
            });
        };
    };
};

/*
Can't do lte because can't sort keys (could be objs)
// Ord :: a -> a -> Boolean
// true at either (for sorted list of keys):
// -first index where xs[key] < ys[key]
// -first index where xs is missing one of ys keys
// -both objects identical for all keys
const lte = function (content_type) {
    return function (ys) {
        return function (xs) {
            // if .some() finishes, default result is that all xs lte ys
            let result = true;

            // Create an object with all the keys from both objects
            const key_list = concat (
                map (constant (true)) (xs)
            ) (
                map (constant (true)) (ys)
            );

            key_list.keys().sort().some(function (key) {

                // ys has a prop not in xs - end loop, is lte
                if (!xs.has(key)) {
                    return true;
                }

                // xs has a prop not in ys - end loop, not lte
                // if xs is empty, will never reach this
                if (!ys.has(key)) {
                    result = false;
                    return true;
                }

                // keep iterating - still equal
                if (content_type.equals (ys.get(key)) (xs.get(key))) {
                    return false;
                }

                // done - found a prop where lte
                if (content_type.lte (ys.get(key)) (xs.get(key))) {
                    return true;
                }

                // By default, ys[key] > xs[key] - failed!
                result = false;
                return true;
            });

            return result;
        };
    };
};
*/

const type_factory = function (type_of) {
    let base_type = {
        spec: "StaticLand",
        version: 1,
        type_name: "esMap_Dictionary",
        map,
        alt,
        zero,
        ap,
//        extend,
        reduce,
        traverse,
        filter,
        concat,
        empty,
        append,
//        indexer,
        create,
        validate: is_object
    };

    if (is_object (type_of)) {

        const check_for_prop = flip (object_has_property) (type_of);

        if (check_for_prop ("equals")) {
            base_type.equals = map_equals (type_of);
        }

//        if (check_for_prop ("lte")) {
//            base_type.lte = lte (type_of);
//        }

//        if (check_for_prop ("validate")) {
//            base_type.validate = validate (type_of);
//        }

        base_type.type_name += "< " + type_of.type_name + " >";
    }

    return Object.freeze(base_type);
};

/*
*/

export default Object.freeze(type_factory);
