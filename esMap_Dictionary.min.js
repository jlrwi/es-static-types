/*jslint
    unordered
*/

import {
    flip,
    pipe
} from "@jlrwi/combinators";
import {
    object_has_property,
    functional_new,
    map_get,
    map_set,
    is_object
} from "@jlrwi/esfunctions";

const set = map_set;
const get = map_get;

const create = function (key) {
    return function (val) {
        return Object.freeze(new_map([[key, val]]));
    };
};

const new_map = functional_new(Map);

// Semigroup :: <a> -> <a> -> <a>
// With overwriting duplicate keys
const concat = function (objA) {
    return function (objB) {
        let result = new_map(objA);
        objB.forEach(function (val, key) {
            result.set(key, val);
        });
        return Object.freeze(result);
    };
};

// Monoid :: () -> {}
const empty = new_map;

const append = map_set;

// Functor :: (a -> b) -> <a> -> <b>
const map = function (f) {
    return function (xs) {
        let obj = new_map();
        xs.forEach(function (val, key) {
            obj.set(key, f(val));
        });
        return Object.freeze(obj);
    };
};

// Bifunctor :: (a -> c) -> (b -> d) -> <a: c> -> <b: d>
const bimap = function (f) {
    return function (g) {
        return function (xs) {
            let result = new_map();
            xs.forEach(function (val, key) {
                result.set(f(key), g(val));
            });
            return Object.freeze(result);
        };
    };
};

// Alt :: <a> -> <a> -> <a>
// With overwriting duplicate keys
const alt = concat;

// Plus :: () -> {}
const zero = empty;

// Functor :: <(a -> b)> -> <a> -> <b>
const ap = function (fs) {
    return function (xs) {
        let res = new_map();
        fs.forEach(function (f, key) {
            const val = xs.get(key);
            if (val !== undefined) {
                res.set(key, f(val));
            }
        });
        return Object.freeze(res);
    };
};

// Traversable :: Applicative<U> -> (a -> U<b>) -> <a> -> U<<b>>
const traverse = function (of_T) {
    return function (f) {
        return reduce(function (acc) {
            return function (val) {
                const first = val.entries().next().value;
                const key = first[0];
                const value = first[1];

// Make an apply that's waiting for the acc to concat
                return of_T.ap(
                    of_T.map(
// Make the result of f back into an object, then concat
                        pipe(
                            create(key)
                        )(
                            flip(concat)
                        )
                    )(
                        f(value)
                    )
                )(
                    acc
                );
            };
        })(
            of_T.of(new_map())
        );
    };
};

// Foldable :: ((c, (a, b)) -> c) -> c -> <a: b> -> c
const reduce = function (f) {
    return function (initial) {
        return function (xs) {
            let acc = initial;
            xs.forEach(function (val, key) {
                acc = f(acc)(create(key)(val));
            });
            return acc;
        };
    };
};

// Filterable :: (a -> Boolean) -> <a> -> <a>
const filter = function (f) {
    return function (xs) {
        let result = new_map();
        xs.forEach(function (val, key) {
            if (f(val) === true) {
                result.set(key, val);
            }
        });
        return Object.freeze(result);
    };
};

// Setoid :: a -> a -> boolean
const map_equals = function (content_type) {
    return function (xs) {
        return function (ys) {

            // Verify xs has all of ys properties
            if (!Array.from(ys.keys()).every(function (key) {
                return xs.has(key);
            })) {
                return false;
            }

// Will catch if ys doesn't have all of xs props
            return Array.from(xs.keys()).every(function (key) {
                return content_type.equals(xs.get(key))(ys.get(key));
            });
        };
    };
};

// Can't do lte because can't sort keys (could be objs)
// Can't do extend for same reason

const type_factory = function (type_of) {
    let base_type = {
        spec: "curried-static-land",
        version: 1,
        type_name: "esMap_Dictionary",
        map,
        bimap,
        alt,
        zero,
        ap,
        reduce,
        traverse,
        filter,
        concat,
        empty,
        append,
        set,
        get,
        create,
        validate: is_object
    };

    if (is_object(type_of)) {

        const check_for_prop = flip(object_has_property)(type_of);

        if (check_for_prop("equals")) {
            base_type.equals = map_equals(type_of);
        }

//        if (check_for_prop ("validate")) {
//            base_type.validate = validate (type_of);
//        }

        base_type.type_name += "< " + type_of.type_name + " >";
    }

    return Object.freeze(base_type);
};

/*
*/

export default Object.freeze(type_factory);
